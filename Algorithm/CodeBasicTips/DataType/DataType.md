# 자료형

![[https://bigpicture123.tistory.com/583](https://bigpicture123.tistory.com/583)](images/image.png)

[https://bigpicture123.tistory.com/583](https://bigpicture123.tistory.com/583)

<br>

# 정수 자료형

## 값 범위

- byte, short, int, long, char
    
    
    | 자료형 | 크기 | 부호 여부 | 값 범위 |
    | --- | --- | --- | --- |
    | byte | 1바이트 | singed | -2⁷ ~ 2⁷-1 ( -128 ~ 127 ) |
    | short | 2바이트 | singed | -2¹⁵ ~ 2¹⁵-1 ( -32,768 ~ 32,767 ) |
    | int | 4바이트 | singed | -2³¹ ~ 2³¹-1 (약 -21억 ~ 21억)
    ( -2,147,483,648 ~ 2,147,483,647 ) |
    | long | 8바이트 | singed | -2⁶³ ~ 2⁶³-1 (약 -922경 3천억 ~ 922경 3천억)
    ( -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 ) |
    | char | 2바이트 | unsined | 0 ~ 65535 |
    - signed
        - 양수/음수 모두 표현 (최상위 비트가 부호 비트)
    - unsigned
        - 음수 없음 (양수만 표현)
    - 보통 int를 많이 사용하는데 int 형 범위 넘는 수를 저장해야하면 long 사용

## Integer Overflow

- 정수형 변수가 저장할 수 있는 최대값을 초과할 때, 값이 반대쪽 최소값으로 순환(랩어라운드)되는 현상
    
    ```java
    byte b = 127;
    b += 1;  // 오버플로우 발생!
    System.out.println(b);  // -128 출력됨 (원래 예상값은 128)
    ```
    
    ```java
    int a = Integer.MAX_VALUE;  // 2,147,483,647
    a += 1;  // 오버플로우 발생!
    System.out.println(a);  // -2,147,483,648 출력됨 (예상값은 2,147,483,648)
    ```
    
    - 주의해야하는 이유
        - 예상 값과 틀린 답을 내는데 오류가 안남 → 디버깅 어려움
        - 오류 발생 예시
            1. func1 (hi를 128번 출력하는 함수)
                
                ```java
                void func1() {
                    for (byte s = 0; s < 128; s++) {
                        System.out.print("hi");
                    }
                }
                ```
                
                - s 가 127에서 128로 넘어갈때 오버플로우 발생
                - s가 -128로 랩어라운드 돼서 무한 루프 발생
                - 오버플로우 발생안되게 하려면
                    - s의 자료형을 int로 바꿔야함
            2. func3 (10의 10거듭제곱을 1000000007 로 나눈 나머지를 반환하는 함수)
                
                ```java
                int func3() {
                    int a = 10;
                    int mod = 1000000007;
                    for (int i = 0; i < 10; i++) {
                        a = 10 * a % mod;
                    }
                    return a;
                }
                
                ```
                
                - a가 $10^9$일때 10이 곱해지는 순간 int의 최대 범위 넘어서 오버플로우 발생
                - 오버플로우 발생안되게 하려면
                    - a의 자료형을 long으로 선언하거나
                    - a = (int)((long)a * 10 % mod);  // a를 long으로 형변환해서 곱셈 후 다시 int로 캐스팅
    
    - 만약 long을 넘어가는 수를 저장해야하는 경우?
        - BigInteger (Java 표준 라이브러리) 사용
            - long 을 넘어서는 정수도 저장/계산 가능
            - 무한대 크기의 정수를 다룰 수 있음 (메모리가 허락하는 한)
            - 단, 성능 느림
            - 연산 시 `.add()`, `.multiply()` 같은 메서드 사용해야함 (연산자 +, * 안 됨).
    

# 실수 자료형

- 실수 자료형 2진수 관점 이해
    - 3을 이진수로 표현하면?
        - 3 = 2¹ + 2⁰ = 11₂
    - 3.75는 이진수로 어떻게 표현할까?
        - 2의 음수 거듭제곱 사용
        - 3.75 = 2 + 1 + 0.5 + 0.25 = 2¹ + 2⁰ + 2⁻¹ + 2⁻² = 11.11₂
    - 10진수의 무한소수 표현을 2진수로도 표현할 수 있을까?
        - 1/3 = 2⁻² + 2⁻⁴ + 2⁻⁶ + 2⁻⁸ + ⋯ = 0.010101⋯₂
    - 10진수에서 편의를 위해 소수점을 10의 제곱수로 나타내는 것처럼 2진수도 표현 가능
        - 3561.234 = 3.561234 × 10³
        - 11101.001₂ = 1.1101001₂ × 2⁴
    

## 값 범위

- float, double
    
    
    | 자료형 | 크기 | 구성 | 값 범위 |
    | --- | --- | --- | --- |
    | float | 4바이트 (32비트) | sign(1) + exponent(8) + fraction(23) | 약 ±1.4 × 10⁻⁴⁵ ~ ±3.4 × 10³ |
    | double | 8바이트 (64비트) | sign(1) + exponent(11) + fraction(52) | 약 ±4.9 × 10⁻³²⁴ ~ ±1.8 × 10³⁰ |
    
    ![IEEE 754 부동소수점 표준(실수를 이진수로 표현할때 사용하는 국제 표준)](images/image%201.png)
    
    IEEE 754 부동소수점 표준(실수를 이진수로 표현할때 사용하는 국제 표준)
    
    - sign field
        - 해당 수가 음수인지 양수인지 저장하는 필드
        - 음수면 1, 양수면 0
    - exponent field
        - 과학적 표기법에서의 지수를 저장하는 필드
    - fraction field
        - 유효숫자 부분 저장하는 필드
    - 예시
        
        ![image.png](images/image%202.png)
        
        - 각 필드 설명
            1. 부호 비트 (1비트)
                - 음수니까 1
            2. 지수비트 (8비트)
                - 지수 를 저장해야하는데
                - 바이어스(bias)를 더해줘야함 (float은 127)
                    - 예시
                        - 실제 지수 = 2
                        - 저장 지수 = 2 + 127 = 219 = 10000001₂
                - Q. 바이어스(bias) 란?
                    - 지수(exponent)를 양수와 음수 모두 표현할 수 있도록 지수 값에 더해주는 일정한 상수값
                    - 부동소수점 표현에서 필수적인 요소
                    - bias = $2^{(지수 비트 수 - 1)}$ - 1
                        - float의 바이어스는 127
                            - 지수가 8비트 → 0 ~ 255 표현 가능 → 바이어스 127 ( = 2⁷ - 1)
                            - 실제 지수값 = 저장된 값 - 바이어스(127)
                            - 예시
                                - 123.45 = 1.2345 × 10² (**지수 2**)
                                    - 실제 지수 2 → 저장 지수 = 2 + 127 = 129
                                - 0.00123 = 1.23 × 10⁻³ (**지수 -3**)
                                    - 실제 지수 -3 → 저장 지수 = -3 + 127 = 124
                        - double의 바이어스는 1023
                            - 지수가 11비트 → 바이어스 1023 ( = $2^{10}$ - 1)
                    - 왜 사용하는지?
                        - 지수 필드를 0부터 시작하는 부호 없는 수로 하면 하드웨어가 더 간단하게 설계 가능 (음수 처리 안 해도 됨)
                        - 대신 바이어스를 이용해 음수 지수까지 표현 가능하게 만든것!
            3. 가수 비트 (23비트)
                - 가수는 1.1011에서
                    - 1은 생략(hidden bit)
                    - 남은 1011 채워넣고
                    - 부족한 자리는 0으로 채움
                        - 1011000...000 (23비트)
        - 최종 저장 구조
            
            ```java
            1    | 10000001 | 1011000...000
            부호 |    지수   | 가수           -> 총 32 비트
            ```
            
        - 요약
            - -6.75 → float로 저장하면:
                - 부호: 1
                - 지수: 129 (10000001₂)
                - 가수: 1011 (1은 생략) → 1011000... (23비트)

## 실수의 성질 (**중요)

1. 실수의 저장과 연산 과정에선 반드시 오차가 발생할 수 밖에 없다.
    - float이 오차가 더 크게 발생하기 때문에 double을 쓰는 것이 더 안전함
        - float이 메모리를 적게 쓴다는 장점이 있지만 거의 대부분의 알고리즘 문제는 double로 해결 가능
        - 원인
            - 유효숫자가 들어가는 fraction field가 유한하기 때문에 2진수 기준으로 무한소수인걸 저장하려고 할때 어쩔수없이 float은 앞 23bit, double은 앞 52bit 까지만 잘라서 저장할 수 밖에 없음
            - 0.1은 이진수로 나타내면 무한소수여서 애초에 오차가 있는 채로 저장이되고 세번 더하면 오차가 더 커져서 0.3과 달라짐 (0.2, 0.3 등도 정확하게 표현 불가)
                
                ```java
                public class Main {
                    public static void main(String[] args) {
                        if (0.1 + 0.1 + 0.1 == 0.3) {
                            System.out.println("true");
                        } else {
                            System.out.println("no no...");
                        }
                    }
                }
                
                /** result **
                no no...
                *************/
                ```
                
            - fraction field로 각 자료형이 어디까지 정확하게 표현할 수 있는지?
                - float
                    - 유효숫자 6자리
                    - 상대오차 $10^{-6}$ 까지 안전
                - double
                    - 유효숫자 15자리
                    - 상대오차 $10^{-15}$ 까지 안전
                - 즉, 오차가 발생하는걸 막을 수는 없지만 오차가 어느정도인지는 알 수 있음
        - 실수 자료형은 필연적 오차가 발생되므로 실수 자료형 필요한 문제에선 보통 절대/상대 오차 허용 한다는 단서 줌
            - 만약 아래와 같은 단서 없으면 대부분 정수로 해결할 수 있는 문제
            
            ![image.png](images/image%203.png)
            

1. double에 long 범위의 정수를 함부로 담으면 안된다.
    - double 정수부의 유효 비트 범위를 초과하는 값을 저장하면 근사값으로 저장되어 오차 발생
        - a와 b는 정수부가 53비트를 초과하는 값
        - 근사값으로 저장되어 동일한 값으로 저장됨
        - int는 21억이므로 저장해도 괜찮음
        
        ```java
        public class Main {
            public static void main(String[] args) {
                double a = 10000000000000001d;
                double b = 10000000000000000d;
        
                if (a == b) {
                    System.out.println("wow..");
                } else {
                    System.out.println("a != b");
                }
            }
        }
        
        /** result **
        wow..
        *************/
        ```
        

1. 실수를 비교할때는 등호를 사용하면 안된다.
    - 실수의 저장과 연산과정에선 반드시 오차가 발생할 수 밖에 없기 때문
        - 등호(==)를 사용하기보단 두 수의 차가  약 $10^{-12}$ 이하 일때 동일하다고 처리하는 것이 안전함
        - 코드에서 $10^{-12}$ 어떻게 표현하는지?
            - 1e-12
            - 비슷하게 10^9 는 1e9 라고 표현함
        
        ```java
        public class Main {
            public static void main(String[] args) {
                double a = 0.1 + 0.1 + 0.1;
                double b = 0.3;
        
                if (a == b) {
                    System.out.println("same 1");
                }
        
        				// 1e-12 가 10^-12 표현
                if (Math.abs(a - b) < 1e-12) {
                    System.out.println("same 2");
                }
            }
        }
        
        /** result **
        same 2
        *************/
        ```